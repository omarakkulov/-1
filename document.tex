\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{misccorr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{hyperref}

\definecolor{linkcolor}{HTML}{799B03} % цвет ссылок
\definecolor{urlcolor}{HTML}{799B03} % цвет гиперссылок
\hypersetup{pdfstartview=FitH,  linkcolor=linkcolor, urlcolor=urlcolor, colorlinks=true}

\numberwithin{equation}{section}

\begin{document}
	
% НАЧАЛО ТИТУЛЬНОГО ЛИСТА
\begin{center}
\hfill \break
\large{МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ}\\
\footnotesize{имени М.В. ЛОМОНОСОВА}\\
\footnotesize{МЕХАНИКО-МАТЕМАТИЧЕСКИЙ ФАКУЛЬТЕТ}\\
\hfill \break
\small{\textbf{А. В. Чашкин}}\\
\small{\textbf{ЛЕКЦИИ}}\\
\small{\textbf{ПО ДИСКРЕТНОЙ МАТЕМАТИКЕ}}\\
\hfill \break
\normalsize{Учебное пособие}\
\end{center}
\newpage	
	\tableofcontents
	\newpage

	\section{Каскадные коды}
	
	В 1965 г. Г. Форни предложил метод комбинирования двух кодов для построения нового кода, длина и скорость которого равны произведению длин и скоростей исходных кодов, а кратность ошибок, исправляемых новым кодом, не меньше произведения кратностей ошибок, исправляемых исходными кодами. При этом главное достоинство метода Форни заключается в том, что декодирование нового кода сводится к последовательномуприменению алгоритмов декодирования исходных кодов.
	
	
	Пусть $G_1$ -- двоичный линейный $(n_1, k_1)$-код, исправляющий $t1$ ошибок. Любой элемент $\bf g1$ этого кода является линейным преобразованием $\bf G1(a1)$ двоичного вектора $\bf a_2$ длины $k_1$. Пусть $q = 2^{{k}_{1}}$ и $G_2$ -- $q$-ичный линейный $(n2, k2)$-код, исправляющий $t2$ ошибок. Любой элемент $\bf g2$ $= (b_1,...,b_{n2} )$ кода $G2$ является вектором длины $n2$, каждый элемент $b_i$ которого можно представить в виде двоичного вектора $\bf b_i$ длины $k_1$. Каскадным двоичным
	$(n_1n_2, k_1k_2)$-кодом $H$ с внутренним кодом $G_1$ и внешним кодом $G_2$ называется множество $\left\{{h}_{j}\right\}$, где любой элемент $\bf h$ получен из соответствующего элемента $\bf g_2$ 
	$= (b_1,...,{{b}_{n2}} )$ кода $G2$ подстановкой вектора $\bf G1(b_i)$ вместо элемента $b_i$, т.е. $\bf h$ $= (G_1(b_1),...,G_1({{b}_{n2}} ))$. Нетрудно видеть, что код $H$ состоит из $2^{k_1k_2}$ элементов, и его скорость $R$ равна произведению скоростей $R_1$ и $R_2$ кодов $G_1$ и $G_2$.
	
	Кодирование кодом
	$H$ выполняется следующим образом. Информационная двоичная последовательность делится на блоки по $k_1k_2$ символов. Затем каждый блок длины $k_1k_2$ делится на блоки длины $k_1$, после чего блоки
	длины $k_1$ рассматриваются как элементы поля $GF(2^{{k}_{1}})$, и $k2$ таких блоков кодируются внешним кодом
	$G2$ в состоящие из элементов поля $GF(2^{{k}_{1}})$
	блоки длины
	$n_2$. Наконец, каждый элемент $GF(2^{{k}_{1}})$ в таком блоке рассматривается как двоичный вектор длины $k_1$ и кодируется внутренним кодом $G_1$ в двоичный вектор длины
	$n_1$. В результате исходный двоичный блок
	длины $k_1k_2$ преобразуется в двоичный блок длины $n_1n_2$.
	
	Декодирование выполняется в обратном порядке. Подлежащая декодированию двоичная последовательность делится на блоки по $n_1n_2$ символов.
	Затем каждый блок длины $n_1n_2$ делится на $n_2$ блоков длины $n_1$, после чего эти блоки рассматриваются как элементы кода $G_1$ и декодируются в блоки
	длины $k_1$, которые, в свою очередь, далее рассматриваются как элементы
	поля $GF(2^{{k}_{1}})$. Наконец блок из
	$n_2$ таких элементов декодируется внешним
	кодом
	$G_2$ в блок длины $k_2$, каждый элемент которого рассматривается как
	двоичная последовательность длины $k_1$. В результате декодируемый двоичный блок длины
	$n_1n_2$ преобразуется в двоичный блок длины $k_1k_2$. Нетрудно
	видеть, что набор длины
	$n_1n_2$ будет декодирован неправильно только в том
	случае, когда в этом наборе найдется не меньше чем $t_2+1$ блоков длины
	$n_1$,
	в каждом из которых произойдет не меньше чем $t_1+1$ ошибок. Таким образом, рассмотренный алгоритм декодирования позволяет исправлять все
	ошибки, кратность которых не превосходит $t_1t_2 + t_1 + t_2$.
	
	Пусть $\epsilon$ -- произвольно малая положительная постоянная. Рассмотрим
	линейный код
	$G_1$ длины $n$, укоторого вероятность неправильного декодирования не превосходит $\epsilon$, а скорость не меньше 
	$1$--$H(p)$--$\epsilon$. Существование
	такого кода следует из прямой теоремы Шеннона о кодировании в двоичном
	симметричном канале. Будем полагать, что код $G_1$ состоит из $2^m$ элементов. Пусть
	$G_2$ -- код Рида–Соломона длины
	$N$ $=$ $2^{m}-1$, исправляющий 
	$2\epsilon N$
	ошибок. Очевидно, что скорость
	$G_2$ не меньше $1-4\epsilon $. Каскадный код
	$G$ с внутренним кодом
	$G_1$ и внешним кодом
	$G_2$ будет иметь длину $nN$, скорость
	не меньше чем
	
	$$\left(1-H\left(p\right)-\epsilon \right)\left(1-4\epsilon \right)
	=
	1-H\left(p\right)-\epsilon\left(5-H\left(p\right)-4\epsilon\right)
	>1-H(p)-5\epsilon$$
	
	а из этого следует, что при достаточно больших $n$ и $N$ для вероятности $P$ неправильного декодирования кода $G$ имеет место неравенство 
	
	Кстати, классная формула \ref{formula}
	
	\begin{equation}\label{formula}
	P\le \sum _{i\ge 4e}\left(\begin{array}{c}N\\ i\end{array}\right){\epsilon }^{i}{\left(1-\epsilon \right)}^{N-i}x\le {N}^{{2}^{\nu N}}\le \epsilon 
	\end{equation}
	
	При этом нетрудно видеть, что сложность декодирования кода
	G есть $(nN)^{{O}{(1)}}$.
	
	Таким образом, каскадные коды позволяют передавать информацию по
	двоичному симметричному каналу с скоростью, сколь угодно близкой к
	максимально возможной для данного канала, сколь угодно малой вероятностью неправильного декодирования и полиномиальной, относительно
	длины кода, сложностью декодирования.
	
Создатель этого шедевра))0)0) \href{https://vk.com/omar_akkulov}{https://vk.com/omar\_akkulov}

\end{document}